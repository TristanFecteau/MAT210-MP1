package mat210;

/**
 * Fichier distribu√© dans le cadre du cours MAT210, session automne 2021, √† l'√âTS.
 *
 * Par Xavier Proven√ßal.
 *
 * Modifications par les √©tudiant¬∑e¬∑s : 
 *  - TODO inscrivez vos noms ici.
 *  - TODO inscrivez vos noms ici.
 *  - TODO inscrivez vos noms ici.
 */


import java.nio.ByteBuffer;
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Exception;
import java.util.Random;
import java.security.SecureRandom;
import java.lang.RuntimeException;

public class RSA {


    public static String chiffre(Cle cleRSA, String message) {
        // On r√©cup√®re les infos de la cl√©, soit les entiers n et e.
        Entier n = cleRSA.getModulo();
        Entier e = cleRSA.getExposant();

        // Pour choronom√©trer
        long avant, apres, duree;

        System.out.println("# G√©n√©ration de la graine pour la g√©n√©ration du masque");

        ///////////////////////////////////////////////////////////////////////////////////
        //
        // √âtape 1. Gestion de la graine du g√©n√©rateur pseudo-al√©atoire.
        //

        // Pour obtenir une graine "s√©curitaire" on utilise la classe
        // SecureRandom afin d'obtenir un nombre choisi al√©atoirement.
        SecureRandom secureRandom = new SecureRandom();
        long graineAsLong = secureRandom.nextLong();

        // Pour faciliter le d√©bogage, on affecte toujours la m√™me valeur √† la graine.
        // Lorsque votre code sera fonctionnel, il faudra retirer la ligne suivante :
        graineAsLong = 2L; // TODO : vous serez p√©nalis√©s si cette ligne est encore l√†.

        // On stocke la graine dans un objet de la classe Entier.
        // On utilise la fonction Long.toUnsignedString car la graine est
        // possiblement n√©gative. Cette fonction force l'interpr√©tation de la
        // graine comme √©tant un nombre positif.
        Entier graineAsEntier = new Entier(Long.toUnsignedString(graineAsLong));
        System.out.println("# Graine du g√©n√©rateur pseudo-al√©atoire : " + graineAsEntier);

        // Validation de la taille de la cl√© RSA. 
        // Si n est plus petit que la graine celle-ci ne peut pas √™tre
        // chiffr√©e.
        if (n.plusPetitOuEgal(new Entier(graineAsEntier))) {
            throw new RuntimeException("Erreur, la cl√© RSA est trop petite pour chiffre"
                   + " la graine du g√©n√©rateur pseudo-al√©atoire. L'exposant de la cl√©" 
                   + " doit faire au moins 64 bits.");
        }



        ///////////////////////////////////////////////////////////////////////////////////
        //
        // √âtape 2. Chiffrement de la graine via la m√©thode RSA
        //
        // Utilisez la cl√© RSA pass√©e en param√®tre afin de chiffrer la graine.
        //

        System.out.print("# Chiffrement RSA de la graine");
        avant = System.nanoTime();

        // TODO

        apres = System.nanoTime();
        duree = (apres-avant)/1000000;
        System.out.println(" (calcul√© en " + duree + " ms)");



        ///////////////////////////////////////////////////////////////////////////////////
        //
        // √âtape 3. Convertir le message sous la forme d'un tableau d'octets
        //
        // Cette conversion est d√©j√† cod√©e et disponible via la fonction
        // `public byte[] texteVersOctets(String texte)` de la classe
        // Convertisseur.

        // TODO



        ///////////////////////////////////////////////////////////////////////////////////
        //
        // √âtape 4. Construire le masque binaire.
        //
        // Il faut construire un tableau d'octets de la m√™me taille que celui
        // qui contient le message original.
        //
        // Aide : 
        //
        //  - pour obtenir la taille d'un tableau t, on fait `t.length`
        //
        //  - pour d√©clarer un tableau d'octets `t` de taille n, on fait `byte[] t = new byte[n];`
        //
        //  - pour inscrire octets al√©atoires dans un tableau d'octets, on
        //    utilise la fonction `public void nextBytes(byte[] bytes)` de la
        //    classe Random.
        //
        //  - avant d'utiliser la fonction `nextBytes`, il faut initialiser un
        //    objet de la classe `Random`. Assurez-vous que cet objet est
        //    initialis√© avec la graine obtenue √† l'√©tape 1.
        //
        // Documentation : https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html

        System.out.print("# G√©n√©ration d'un masque binaire");
        avant = System.nanoTime();

        // TODO

        apres = System.nanoTime();
        duree = (apres-avant)/1000000;
        System.out.println(" (calcul√© en " + duree + " ms)");



        ///////////////////////////////////////////////////////////////////////////////////
        //
        // √âtape 5. Chiffrement du texte avec le masque binaire
        //
        // Aide : 
        //
        //  - En Java, l'op√©rateur xor (ou exclusif) est ^
        //  - cet op√©rateur est d√©finit uniquement sur le type int. Ainsi, si
        //    p, q, r d√©sigent trois octets, pour affecter `q xor r` dans `p`,
        //    en Java, il faut √©crire : `p = (byte) ( q ^ r );`
        //
        //  - Appliquez le masque binaire sur les octets du message original et
        //    conservez le r√©sultat dans un nouveau tableau d'octets.
        //
        //

        System.out.print("# Chiffrement du message avec un masque binaire");
        avant = System.nanoTime();

        // TODO        

        apres = System.nanoTime();
        duree = (apres-avant)/1000000;
        System.out.println(" (calcul√© en " + duree + " ms)");



        ///////////////////////////////////////////////////////////////////////////////////
        //
        // √âtape 6. Convertir les octets chiffr√©s en un entier.
        //
        // Pour cela, on utilise la fonction `public static Entier octetsVersEntier(byte[] octets)`
        // de la classe `Convertisseur`.
        //

        // TODO



        ///////////////////////////////////////////////////////////////////////////////////
        //
        // √âtape 7. Retourner le message chiffr√©
        //
        // On construit une cha√Æne de caract√®res form√©e de :
        //
        // 1. la repr√©sentation textuelle de l'entier obtenu par le chiffrement de la cl√© (√©tape 4)
        // 2. une virgule
        // 3. la repr√©sentation textuelle de l'entier obtenu par le chiffrement du message (√©tape 6)
        //
        
        // TODO        

        return "bug"; // return bidon (pour que √ßa compile) √Ä RETIRER !
    }

    public static String dechiffre(Cle cleRSA, String messageChiffre) {
        // On r√©cup√®re les infos de la cl√©
        Entier n = cleRSA.getModulo();
        Entier d = cleRSA.getExposant();

        // Pour choronom√©trer
        long avant, apres, duree;


        ///////////////////////////////////////////////////////////////////////////////////
        //
        // √âtape 1. S√©parer les donn√©es
        //
        // Le message chiffr√© est de la forme : 234541356431564333,43514354361434356413543154354135
        //
        //  - le premier nombre est la graine du g√©n√©rateur pseudo-al√©atoire chiffr√©e par le RSA.
        //  - le deuxi√®me nombre est le message chiffr√© par un masque binaire.
        //
        //  Utilisez la fonction `split` de la classe `String` afin de
        //  r√©cup√©rer les deux nombre sous la formed de cha√Ænes de caract√®res,
        //  puis utilisez le constructeur `Entier(String s)` pour construire
        //  les entiers correspondants.
        //
        //  Documentation : https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#split(java.lang.String)
        //
       
        // TODO

        ///////////////////////////////////////////////////////////////////////////////////
        //
        // √âtape 2. D√©chiffrez la graine √† l'aide de la cl√© RSA pass√©e en param√®res.
        //

        System.out.print("# D√©chiffrement RSA de la graine");
        avant = System.nanoTime();

        // TODO

        apres = System.nanoTime();
        duree = (apres-avant)/1000000;
        System.out.println(" (calcul√© en " + duree + " ms)");
        System.out.println("# Graine du g√©n√©rateur pseudo-al√©atoire : " ); // TODO afficher la graine


        ///////////////////////////////////////////////////////////////////////////////////
        //
        // √âtape 3. D√©chiffrez la graine √† l'aide de la cl√© RSA pass√©e en param√®res.
        //
        // Utilisez la fonction `Long.parseUnsignedLong(String s)` afin de
        // convertir la graine en `Long`.
        //
        // Aide : 
        //  - √âtant donn√© un Entier e, on obtient sa repr√©sentation en String
        //    en faisant `e.str()`.
        //
        // Note :
        //  - Il est possible que le `long` obteniue soit n√©gatif. Ce n'est pas
        //    un probl√®me. Cela sera expliqu√© en d√©tail au cours #6.
        //
        
        // TODO


        ///////////////////////////////////////////////////////////////////////////////////
        //
        // √âtape 4. D√©chiffrer le message avec le masque binaire.
        //
        // La construction du masque binaire et son utilisation est identique √†
        // ce que vous avez fait √† l'√©tape 5 de la fonction `chiffre`.
        //
        // N'oubliez pas d'initialiser correctement le g√©n√©rateur
        // pseudo-al√©atoire.
        //
        System.out.print("# D√©chiffrement du message avec le masque binaire");
        avant = System.nanoTime();

        // TODO

        apres = System.nanoTime();
        duree = (apres-avant)/1000000;
        System.out.println(" (calcul√© en " + duree + " ms)");

        ///////////////////////////////////////////////////////////////////////////////////
        //
        // √âtape 5. Convertir les octets d√©chiffr√©s en une cha√Æne de caract√®re.
        //
        // C'est d√©j√† tout cod√© dans la classe `Convertisseur`.
        //

        // TODO        

        return "bug"; // return bidon (pour que √ßa compile) √Ä RETIRER !
    }


    public static void main(String[] args) {

        // Si vous ne souhaitez pas utiliser les arguments de la ligne de
        // commande, vous pouvez les simuler en r√©affectant ``args`` sur un
        // nouveau tableau de String.
        // ATTENTION : pensez √† commenter ces lignes AVANT de rendre votre travail !
        //args = new String[] {"--chiffre", "--cle", "cle", "Boum"};
        //args = new String[] {"--chiffre", "--cle", "cle", "Bonjour toto"};


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//// √Ä partir d'ici, tout ce qui suit n'est pas pertinant dans le cadre ////
//// du cours MAT210.                                                   ////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

        String operation = null;;
        String fichierCle = null;;
        String messageOriginal = null;;

        // Lecture des arguments de la ligne de commande
        for (int i=0; i<args.length; ++i) {
            if (args[i].equals("--chiffre")) {
                operation = "chiffre";
            } else if (args[i].equals("--dechiffre")) {
                operation = "dechiffre";
            } else if (args[i].equals("--cle")) {
                fichierCle = args[i+1];
                ++i;
            } else if (args[i].equals("--demoConversion")) {
                operation = "demo";
            } else if (args[i].equals("--entierVersTexte")) {
                operation = "entierVersTexte";
            } else if (args[i].equals("--texteVersEntier")) {
                operation = "texteVersEntier";
            } else if (args[i].equals("--help")) {
                usage();
                System.exit(0);
            } else {
                messageOriginal = args[i];
            }
        }

        if ((operation == null) 
                || (operation.equals("--chiffre") && (messageOriginal == null))
                || (operation.equals("--dechiffre") && (messageOriginal == null))
           ) {
            usage();
            System.exit(1);
        }

        if (operation.equals("chiffre")) {
            Cle cleRSA = new Cle(fichierCle);
            //Entier x = chiffre(cleRSA, messageOriginal);
            String c = chiffre(cleRSA, messageOriginal);
            System.out.println(c);
        } else if (operation.equals("dechiffre")) {
            Cle cleRSA = new Cle(fichierCle);
            String texte = dechiffre(cleRSA, messageOriginal);
            System.out.println(texte);
        } else if (operation.equals("demo")) {
            demoConversion();
        } else if (operation.equals("entierVersTexte")) {
            System.out.println(Convertisseur.entierVersTexte(new Entier(messageOriginal)));
        } else if (operation.equals("texteVersEntier")) {
            System.out.println("" + Convertisseur.texteVersEntier(messageOriginal));
        } else {
            System.out.println("Option : " + operation + ", inconnue");
            usage();
            System.exit(1);
        }

    }

    /**
     * Affiche l'aide pour utiliser ce programme
     */
    private static void usage() {
        System.out.println("\nUsages :\n\n" 
                + "java RSA --chiffre --cle <fichierCle> \"message\"\n"
                + "    Le param√®tre \"message\" est d'abord converti en entier puis chiffr√©.\n"
                + "    Le nombre r√©sultant du chiffrement est affich√© sur la sortie standard.\n"
                + "\n"
                + "java RSA --dechiffre --cle <fichierCle> N\n"
                + "    Le param√®tre N est un nombre, ce nombre est d√©chiffr√© puis converti en\n"
                + "    cha√Æne de caract√®res. Cette cha√Æne est affich√©e sur la sortie standard.\n"
                + "\n"
                + "java RSA --texteVersEntier \"texte\"\n"
                + "    Converti la cha√Æne de caract√®re \"texte\" en une entier.\n"
                + "    Aucune cryptographie n'est impliqu√©e dans cette conversion.\n"
                + "\n"
                + "java RSA --entierVersTexte N\n"
                + "    Converti l'entier N en une cha√Æne de caract√®res.\n"
                + "    Aucune cryptographie n'est impliqu√©e dans cette conversion.\n"
                + "\n"
                + "java RSA --demoConversion\n"
                + "    Affiche quelques exemples de conversion String <--> Entier.\n"
                + "\n"
                + "java RSA --help\n"
                + "    Affiche cet aide.\n"
                );
    }

    /**
     * Affiche des exemples de conversion du texte en entier et vice-versa.
     */
    private static void demoConversion() {
        String s;
        Entier e;

        s = "Bonjour";
        e = Convertisseur.texteVersEntier(s);
        System.out.println("\"" + s + "\" --> " + e);
        s = Convertisseur.entierVersTexte(e);
        System.out.println(e + " --> \'" + s + "\'\n");

        s = "Message secret";
        e = Convertisseur.texteVersEntier(s);
        System.out.println("\"" + s + "\" --> " + e);
        s = Convertisseur.entierVersTexte(e);
        System.out.println(e + " --> \'" + s + "\'\n");

        s = "Ceci est une texte pas mal long, vraiment long!";
        e = Convertisseur.texteVersEntier(s);
        System.out.println("\"" + s + "\" --> " + e);
        s = Convertisseur.entierVersTexte(e);
        System.out.println(e + " --> \'" + s + "\'\n");

        s = "Support Unicode via UTF-8 :üòÄ üòÅ üòÖ üòá ";
        e = Convertisseur.texteVersEntier(s);
        System.out.println("\"" + s + "\" --> " + e);
        s = Convertisseur.entierVersTexte(e);
        System.out.println(e + " --> \'" + s + "\'\n");

    }


    /**
     * Une cl√© RSA est form√©e de deux entiers. Il peut s'agit autant d'une cl√©
     * de chiffrement que de d√©chiffrement.
     *
     * Le calcul du chiffrement/d√©chiffrement RSA est : 
     *
     * M^e mod n
     *
     * o√π M est le message
     *    e est l'exposant
     *    n est le modulo
     *
     * La paire (n, e) forme la cl√© RSA.
     */
    private static class Cle {
        /**
         * Une cl√© est construite √† partir d'un fichier o√π les trois nombres n, d et e sont lus.
         *
         * @param fichier  fichier texte contenant la cl√© RSA
         */
        public Cle(String fichier) {
            FileReader fr = null;
            BufferedReader br = null;
            try {
                fr = new FileReader(fichier);
                br = new BufferedReader(fr);
                String s = br.readLine();
                while (s != null) {
                    if (!(s.isEmpty() || s.startsWith("#"))) {
                        s = s.toLowerCase().trim().replaceAll("\\s+"," ");
                        String[] t = s.split(" ");
                        if (t[0].equals("n")) {
                            modulo = new Entier(t[1]);
                        } else if (t[0].equals("d")) {
                            exposant = new Entier(t[1]);
                        } else if (t[0].equals("e")) {
                            exposant = new Entier(t[1]);
                        } else {
                            throw new Exception();
                        }
                    }
                    s = br.readLine();
                }
            } catch (Exception e) {
                e.printStackTrace();
                System.out.println("ERREUR √† la lecture de la cl√© dans le fichier ``" + fichier + "``");
                System.exit(1);
            } finally {
                try {
                    br.close();
                    fr.close();
                } catch (Exception e) {}
            }
        }

        /**
         * Retourne le modulo.
         */
        public Entier getModulo() {
            return modulo;
        }

        /**
         * Retourne l'exposant.
         */
        public Entier getExposant() {
            return exposant;
        }

        private Entier modulo;
        private Entier exposant;
    }



}
